<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>goroutine和channel | bing随遇而安</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/logo.png">
    <meta name="description" content="
问题
有一个品类的csv文件，大概有3w多条数据，里面只有品类名称这一列，现在需要读取csv中的内容，调用接口实现对该品类的打分，讲返回的数据写入新的csv文件，新的csv文件包括两个字段，品类和对应的分数。由于打分接口逻辑比较复杂，单次执行比较耗时，如果让你用go来实现，应该怎么做呢？

思考
对于上面的问题，可以将主要的功能分为三个函数，csv文件读取、调用接口打分、csv文件 ...">
    
    <link rel="preload" href="/assets/css/0.styles.7de31a01.css" as="style"><link rel="preload" href="/assets/js/app.20f2d714.js" as="script"><link rel="preload" href="/assets/js/6.86d33cf6.js" as="script"><link rel="preload" href="/assets/js/3.122d5fd9.js" as="script"><link rel="preload" href="/assets/js/36.b0bfa1bd.js" as="script"><link rel="prefetch" href="/assets/js/10.8f78e4d8.js"><link rel="prefetch" href="/assets/js/11.2657ec05.js"><link rel="prefetch" href="/assets/js/12.d23da198.js"><link rel="prefetch" href="/assets/js/13.cb896045.js"><link rel="prefetch" href="/assets/js/14.f7014cd5.js"><link rel="prefetch" href="/assets/js/15.d271d8f6.js"><link rel="prefetch" href="/assets/js/16.1ed35f77.js"><link rel="prefetch" href="/assets/js/17.f948313b.js"><link rel="prefetch" href="/assets/js/18.fdec87a3.js"><link rel="prefetch" href="/assets/js/19.c871bc56.js"><link rel="prefetch" href="/assets/js/20.3cc1bb01.js"><link rel="prefetch" href="/assets/js/21.b9d53585.js"><link rel="prefetch" href="/assets/js/22.fb44072f.js"><link rel="prefetch" href="/assets/js/23.050dc1d5.js"><link rel="prefetch" href="/assets/js/24.e780ac86.js"><link rel="prefetch" href="/assets/js/25.80262333.js"><link rel="prefetch" href="/assets/js/26.cea7e97b.js"><link rel="prefetch" href="/assets/js/27.23141d4c.js"><link rel="prefetch" href="/assets/js/28.6e00a82c.js"><link rel="prefetch" href="/assets/js/29.765137d8.js"><link rel="prefetch" href="/assets/js/30.1dfae280.js"><link rel="prefetch" href="/assets/js/31.619710f3.js"><link rel="prefetch" href="/assets/js/32.b2ba2b4e.js"><link rel="prefetch" href="/assets/js/33.8f979719.js"><link rel="prefetch" href="/assets/js/34.77ca4544.js"><link rel="prefetch" href="/assets/js/35.8b63bb58.js"><link rel="prefetch" href="/assets/js/37.a995eb26.js"><link rel="prefetch" href="/assets/js/38.a062b2bf.js"><link rel="prefetch" href="/assets/js/39.d954ad62.js"><link rel="prefetch" href="/assets/js/4.380f1af6.js"><link rel="prefetch" href="/assets/js/40.e6e0cf43.js"><link rel="prefetch" href="/assets/js/41.9c6c775f.js"><link rel="prefetch" href="/assets/js/42.77b86103.js"><link rel="prefetch" href="/assets/js/43.56377a0f.js"><link rel="prefetch" href="/assets/js/44.6cfba6ea.js"><link rel="prefetch" href="/assets/js/45.9fc18aa9.js"><link rel="prefetch" href="/assets/js/46.6237e124.js"><link rel="prefetch" href="/assets/js/47.0f2e95bf.js"><link rel="prefetch" href="/assets/js/48.0a94ac53.js"><link rel="prefetch" href="/assets/js/49.99856a36.js"><link rel="prefetch" href="/assets/js/5.084c9b71.js"><link rel="prefetch" href="/assets/js/50.cf6f1a0e.js"><link rel="prefetch" href="/assets/js/51.4a83ff5a.js"><link rel="prefetch" href="/assets/js/52.ba1346dd.js"><link rel="prefetch" href="/assets/js/53.1c990a56.js"><link rel="prefetch" href="/assets/js/54.576aac00.js"><link rel="prefetch" href="/assets/js/55.a76ea924.js"><link rel="prefetch" href="/assets/js/56.221904c4.js"><link rel="prefetch" href="/assets/js/57.ac62e0fb.js"><link rel="prefetch" href="/assets/js/58.e72496b2.js"><link rel="prefetch" href="/assets/js/59.0e60a760.js"><link rel="prefetch" href="/assets/js/60.f82dec03.js"><link rel="prefetch" href="/assets/js/61.d786dbab.js"><link rel="prefetch" href="/assets/js/62.65521ed5.js"><link rel="prefetch" href="/assets/js/63.e999e220.js"><link rel="prefetch" href="/assets/js/64.54ac400a.js"><link rel="prefetch" href="/assets/js/65.245670f2.js"><link rel="prefetch" href="/assets/js/66.9f292fb6.js"><link rel="prefetch" href="/assets/js/67.4f4ed97a.js"><link rel="prefetch" href="/assets/js/68.61b42ea3.js"><link rel="prefetch" href="/assets/js/69.a5fcafb4.js"><link rel="prefetch" href="/assets/js/7.358fd391.js"><link rel="prefetch" href="/assets/js/70.9490ba98.js"><link rel="prefetch" href="/assets/js/71.e4902e53.js"><link rel="prefetch" href="/assets/js/72.b6d5a4d8.js"><link rel="prefetch" href="/assets/js/73.7f268733.js"><link rel="prefetch" href="/assets/js/74.7a5c3547.js"><link rel="prefetch" href="/assets/js/8.6d90bc1f.js"><link rel="prefetch" href="/assets/js/9.0a60c476.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.ac365ac7.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7de31a01.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/" class="nav-link home-link">bing随遇而安 </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/" class="nav-link">首页</a></li><li class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></li><li class="nav-item"><a href="/data-structure/" class="nav-link">数据结构</a></li><li class="nav-item"><a href="/tag/" class="nav-link">标签</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/" class="nav-link mobile-home-link">bing随遇而安 </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/" class="nav-link">首页</a></li><li class="mobile-nav-item"><a href="/algorithm/" class="nav-link">算法</a></li><li class="mobile-nav-item"><a href="/data-structure/" class="nav-link">数据结构</a></li><li class="mobile-nav-item"><a href="/tag/" class="nav-link">标签</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">BING随遇而安</span> <span itemprop="address">   in Shanghai</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2023-05-13T15:08:41.000Z">
      2023-05-13
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-42ccfcd5><a href="/tag/golang" data-v-42ccfcd5><span data-v-42ccfcd5>golang</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><h1 id="goroutine和channel"><a href="#goroutine和channel" class="header-anchor">#</a> goroutine和channel</h1> <h2 id="问题"><a href="#问题" class="header-anchor">#</a> 问题</h2> <p>有一个品类的csv文件，大概有3w多条数据，里面只有品类名称这一列，现在需要读取csv中的内容，调用接口实现对该品类的打分，讲返回的数据写入新的csv文件，新的csv文件包括两个字段，品类和对应的分数。由于打分接口逻辑比较复杂，单次执行比较耗时，如果让你用go来实现，应该怎么做呢？</p> <h2 id="思考"><a href="#思考" class="header-anchor">#</a> 思考</h2> <p>对于上面的问题，可以将主要的功能分为三个函数，csv文件读取、调用接口打分、csv文件写入函数。其中csv文件读取和csv文件写入函数都比较简单，就不在这里多说了。对于调用品类打分接口，如果串行的话，速度太慢。我们可以启用多个goroutine来并行执行，并将执行的结果统一写入到数据收集的channel中。最后将数据收集的channel中的数据写入csv文件就好。下面，我将带着这个问题来回顾学习一下goroutine+channel，最后来解答上面的问题。</p> <h2 id="学习"><a href="#学习" class="header-anchor">#</a> 学习</h2> <h4 id="goroutine简介"><a href="#goroutine简介" class="header-anchor">#</a> goroutine简介</h4> <p>goroutine 是 Go 语言的一个基础特性。它是一个轻量级的线程,进程内部的线程。</p> <h6 id="goroutine-的主要特征"><a href="#goroutine-的主要特征" class="header-anchor">#</a> goroutine 的主要特征:</h6> <ul><li>轻量级:goroutine 的开销很小,一个进程可以同时运行成百上千个 goroutine。</li> <li>并发:goroutine 可以同时运行,实现并发。</li> <li>共享内存:goroutine 之间可以访问共享内存,主要通过 channel 进行通信。</li> <li>轻量级调度:goroutine 之间的调度开销很小,可以快速在 goroutine 之间切换。</li></ul> <h6 id="goroutine-的用途"><a href="#goroutine-的用途" class="header-anchor">#</a> goroutine 的用途:</h6> <ul><li>实现并发:可以同时运行多个 goroutine,实现并发操作。</li> <li>避免阻塞:当一个 goroutine 执行阻塞操作时,可以切换到其他 goroutine 继续执行,避免主线程阻塞。</li> <li>充分利用多核 CPU:可以启动与 CPU 核心数量相同的 goroutine 最大限度地利用 CPU 资源。</li></ul> <h6 id="goroutine-的实现原理"><a href="#goroutine-的实现原理" class="header-anchor">#</a> goroutine 的实现原理:</h6> <p>Go 语言的运行时(runtime)管理着一个主 Goroutine(Logical Processor)和许多新的 Goroutines。
当主 goroutine 创建新的 goroutine 时,主 goroutine 会得到一个寄存器和栈空间,然后在不同的逻辑处理器上运行 goroutine,模拟出concurrency的效果。
Go 语言的调度器会在逻辑处理器间快速切换 goroutine,让我们感觉所有的 goroutine 是平行执行的,但实际上,任何时刻都只有一个处理器在运行。
goroutine 与线程的区别:</p> <ul><li>线程是进程内的执行单元,goroutine 是 Go 语言的执行单元。</li> <li>线程的调度和切换由 OS 进行管理,goroutine 的调度和切换由 Go 语言的运行时(runtime)进行管理。</li> <li>线程有较大的资源开销, goroutine 的资源开销比较小。一个进程可以创建上万个 goroutine 但同等条件下只能创建有限数量的线程。</li> <li>线程的切换代价比较高,goroutine 的切换代价低廉。所以 goroutine 更适合用于高并发场景。
总之,goroutine 是 Go 语言实现高效的并发编程的关键所在。通过 goroutine 和 channel 的配合可以实现高性能的并发系统。</li></ul> <h6 id="例子"><a href="#例子" class="header-anchor">#</a> 例子</h6> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

	<span class="token comment">// 直接调用</span>
	<span class="token function">f</span><span class="token punctuation">(</span><span class="token string">&quot;direct&quot;</span><span class="token punctuation">)</span>
	<span class="token comment">// go run goroutines.go</span>
	<span class="token comment">// direct : 0</span>
	<span class="token comment">// direct : 1</span>
	<span class="token comment">// direct : 2</span>

	<span class="token comment">// 在一个go的协程中调用这个函数，这个新的go协程会并行执行这个函数调用</span>
	<span class="token keyword">go</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token string">&quot;goroutine&quot;</span><span class="token punctuation">)</span>

	<span class="token comment">// 我们也可以定义一个匿名函数</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>from <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">f</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token string">&quot;goroutine1&quot;</span><span class="token punctuation">)</span>
	<span class="token comment">// 由于是异步执行，所以需要等待执行结束</span>
	<span class="token comment">// time.Sleep(time.Second)</span>
	<span class="token comment">// 同时也可以监听用户输入事件，回车结束</span>
	<span class="token keyword">var</span> input <span class="token builtin">string</span>
	fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>input<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;done&quot;</span><span class="token punctuation">)</span>

	<span class="token comment">// direct : 0</span>
	<span class="token comment">// direct : 1</span>
	<span class="token comment">// direct : 2</span>
	<span class="token comment">// goroutine1 : 0</span>
	<span class="token comment">// goroutine : 0</span>
	<span class="token comment">// goroutine : 1</span>
	<span class="token comment">// goroutine1 : 1</span>
	<span class="token comment">// goroutine1 : 2</span>
	<span class="token comment">// goroutine : 2</span>

	<span class="token comment">// done</span>
<span class="token punctuation">}</span>

<span class="token comment">// 定义一个函数，循环3次输出:&quot;from:index&quot;</span>
<span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span>from <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		<span class="token comment">// 为了能看出多个协程执行效果，每循环一次，休眠1s</span>
		time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>from<span class="token punctuation">,</span> <span class="token string">&quot;:&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="channel简介"><a href="#channel简介" class="header-anchor">#</a> channel简介</h4> <p>channel 是 Go 语言中用于 goroutine 之间通讯的重要工具。channel 可以使一个 goroutine 发送数据,另一个 goroutine 接收数据。</p> <h6 id="channel-的主要特征"><a href="#channel-的主要特征" class="header-anchor">#</a> channel 的主要特征:</h6> <ul><li>通讯机制:channel 可用于 goroutine 之间的<b>数据传输</b>和<b>通信</b>。</li> <li>先进先出:channel 会严格遵循先进先出原则讲数据传递给接收方。</li> <li>阻塞机制:当channel 没有数据时,接收方会阻塞。当channel已满时,发送方会阻塞。</li> <li>并发安全:channel 可以在并发环境下使用,内置了锁机制保证并发安全。</li></ul> <h6 id="channel-的主要用途"><a href="#channel-的主要用途" class="header-anchor">#</a> channel 的主要用途:</h6> <ul><li>解耦:通过 channel 可以使得发送方和接收方解耦,松散耦合。</li> <li>安全通信:channel 是并发安全的,可以在并发环境下使用。</li> <li>同步:通过 channel 可以使得发送方和接收方同步。例如在接收方准备好之前,发送方一直阻塞。</li> <li>流控:通过 channel 可以控制数据流进出的速度,防止数据消耗过快导致接收方来不及处理。</li></ul> <h6 id="channel-的声明语法"><a href="#channel-的声明语法" class="header-anchor">#</a> channel 的声明语法:</h6> <div class="language-go extra-class"><pre class="language-go"><code>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">type</span><span class="token punctuation">,</span> buffSize<span class="token punctuation">)</span>
</code></pre></div><ul><li>type:channel 中传递的数据类型,必须是 gobject 兼容类型。</li> <li>buffSize:可选,指定 channel 的缓冲区大小,默认为 0 表明该 channel 是无缓冲 channel。</li></ul> <p>总之,channel 是 Go 语言实现 goroutine 之间通信的重要工具,它可以使得多个 goroutine 之间保持同步和通讯。通过 channel 可以实现并发编程中常见的工作池、消息传递等模式。</p> <h6 id="例子-2"><a href="#例子-2" class="header-anchor">#</a> 例子</h6> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 通道是连接多个go协程的管道，可以在一个go协程中发送数据到通道，在另外一个协程中接收数据</span>

	<span class="token comment">// 使用 make(chan val-type)来创建一个新的通道。</span>
	messages <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span>
	<span class="token comment">// 使用channel &lt;- 语法发送一个新值到通道，这里在协程中发送数据到messages通道</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		messages <span class="token operator">&lt;-</span> <span class="token string">&quot;ping&quot;</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">// 使用&lt;-channel语法从channel中接收一个值，并打印出来</span>
	message <span class="token operator">:=</span> <span class="token operator">&lt;-</span>messages
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>

	<span class="token comment">// 默认发送和接收操作都是阻塞的，直到发送方和接收方都准备完毕，这个特性可以让我们在不使用其他的同步操作的情况下，在程序结尾的时候等待接收ping消息</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="channel缓冲"><a href="#channel缓冲" class="header-anchor">#</a> channel缓冲</h4> <p>channel 缓冲指 channel 中可存放数据的个数。channel 的缓冲大小可以通过第二个参数指定,语法如下:</p> <div class="language-go extra-class"><pre class="language-go"><code>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">type</span><span class="token punctuation">,</span> bufferSize<span class="token punctuation">)</span>
</code></pre></div><ul><li>type:channel 用于传递的数据类型。</li> <li>bufferSize:指定 channel 可以存放的数据个数,如果省略默认为 0。</li></ul> <h6 id="根据缓冲大小的不同-channel-可以分为"><a href="#根据缓冲大小的不同-channel-可以分为" class="header-anchor">#</a> 根据缓冲大小的不同,channel 可以分为:</h6> <ul><li>无缓冲 channel(bufferSize = 0):发送方发送数据前必须等待接收方接收数据,否则发送方会阻塞。</li> <li>有缓冲 channel(bufferSize &gt; 0):发送方发送的数据先入队列,然后立即返回,直到队列已满后才会阻塞。
无缓冲 channel 和有缓冲 channel 的区别在于:</li> <li>无缓冲 channel:必须等接收方接收消息后才能继续发送消息,否则会阻塞。更像一种同步机制。</li> <li>有缓冲 channel:可以连续发送多个消息而不会阻塞(直到缓冲区满),更像一个队列。接收方可以从队列中接收消息。
下面我们通过例子演示无缓冲 channel 和有缓冲 channel 的区别:</li></ul> <h6 id="有缓冲的channel例子"><a href="#有缓冲的channel例子" class="header-anchor">#</a> 有缓冲的channel例子</h6> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 默认通道是没有缓冲的，这意味着只有在对于的接收通道准备接收数据时，才能进行发送操作。</span>
	<span class="token comment">// 缓冲通道允许，在没有接收方的情况下，缓存一定数量的值</span>

	<span class="token comment">// 创建一个可以缓冲两个值的通道</span>
	messages <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>

	<span class="token comment">// 向通道中发送2个值</span>
	messages <span class="token operator">&lt;-</span> <span class="token string">&quot;buffered&quot;</span>
	messages <span class="token operator">&lt;-</span> <span class="token string">&quot;channel&quot;</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>messages<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>messages<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h6 id="无缓冲的通道例子"><a href="#无缓冲的通道例子" class="header-anchor">#</a> 无缓冲的通道例子</h6> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 默认通道是没有缓冲的，这意味着只有在对于的接收通道准备接收数据时，才能进行发送操作。</span>
	<span class="token comment">// 缓冲通道允许，在没有接收方的情况下，缓存一定数量的值</span>

	<span class="token comment">// 创建一个可以缓冲两个值的通道</span>
	messages <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span>

	<span class="token comment">// 开启新的goroutine向通道中发送2个值</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 发送方发送消息,阻塞</span>
        messages <span class="token operator">&lt;-</span> <span class="token string">&quot;buffered&quot;</span>
	    messages <span class="token operator">&lt;-</span> <span class="token string">&quot;channel&quot;</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 接收方接收消息,发送方解阻塞</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>messages<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>messages<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="channel方向"><a href="#channel方向" class="header-anchor">#</a> channel方向</h4> <h6 id="channel-有两种方向"><a href="#channel-有两种方向" class="header-anchor">#</a> channel 有两种方向:</h6> <ul><li>单向 channel:只能在一个方向上发送和接收消息。</li> <li>双向 channel:可以在两个方向上发送和接收消息。
channel 的方向在定义 channel 时使用 &lt;- 指定:</li> <li>ch := &lt;-chan int:接收用的单向 channel,只能接收不能发送。</li> <li>ch := chan &lt;-int:发送用的单向 channel,只能发送不能接收。</li> <li>ch := chan int:双向 channel,可以发送和接收。</li></ul> <div class="language-go extra-class"><pre class="language-go"><code><span class="token comment">// 创建单向channel</span>
<span class="token keyword">var</span> ch1 <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span>    <span class="token comment">// 只发送</span>
<span class="token keyword">var</span> ch2 <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span>    <span class="token comment">// 只接收</span>
<span class="token comment">// 创建双向channel</span>
<span class="token keyword">var</span> ch3 <span class="token keyword">chan</span> <span class="token builtin">int</span> <span class="token comment">// 接收+发送</span>
</code></pre></div><h6 id="单向-channel-的使用场景"><a href="#单向-channel-的使用场景" class="header-anchor">#</a> 单向 channel 的使用场景:</h6> <ul><li>当我们明确 channel 的使用方向时,使用单向 channel 可以避免误用。</li> <li>减少由于误用 channel 方向导致的 bug,提高程序的健壮性。</li> <li>channel 的发送方和接收方的功能可以更清晰的划分,利于理解。
总之,当程序中 channel 的使用方向是明确的,我们应该使用单向 channel。否则使用双向 channel 会更加灵活。单向 channel 可以在一定程度上避免由于误使用 channel 方向导致的错误。</li></ul> <h6 id="例子-3"><a href="#例子-3" class="header-anchor">#</a> 例子</h6> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 双向channel</span>
	pings <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
	pongs <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>

	<span class="token function">ping</span><span class="token punctuation">(</span>pings<span class="token punctuation">,</span> <span class="token string">&quot;passed message&quot;</span><span class="token punctuation">)</span>
	<span class="token function">pong</span><span class="token punctuation">(</span>pings<span class="token punctuation">,</span> pongs<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>pongs<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 当使用通道作为函数参数的时候，可以制定通道的方向，即是接收通道，还是发送通道</span>

<span class="token comment">// ping 函数定义了一个只允许发送数据的通道。尝试使用这个通道来接收数据将会得到一个编译时错误。</span>
<span class="token keyword">func</span> <span class="token function">ping</span><span class="token punctuation">(</span>pings <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">string</span><span class="token punctuation">,</span> msg <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	pings <span class="token operator">&lt;-</span> msg
<span class="token punctuation">}</span>

<span class="token comment">// pong 函数允许通道（pings）来接收数据，另一通道（pongs）来发送数据。</span>
<span class="token keyword">func</span> <span class="token function">pong</span><span class="token punctuation">(</span>pings <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">,</span> pongs <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// msg := &lt;-pings</span>
	<span class="token comment">// pongs &lt;- msg</span>
	pongs <span class="token operator">&lt;-</span> <span class="token operator">&lt;-</span>pings
<span class="token punctuation">}</span>
</code></pre></div><h4 id="channel状态同步"><a href="#channel状态同步" class="header-anchor">#</a> channel状态同步</h4> <p>channel 除了用于 goroutine 之间的数据传输外,还可以用于 goroutine 之间的同步。
channel 的同步特性体现在:</p> <ul><li>发送方发送数据时如果没有接收方接收数据会阻塞,直到接收方接收数据才会解阻塞。</li> <li>接收方接收数据时如果没有发送方发送数据会阻塞,直到发送方发送数据才会解阻塞。
利用这个特性,我们可以实现 goroutine 之间的同步。</li></ul> <h6 id="例子-4"><a href="#例子-4" class="header-anchor">#</a> 例子</h6> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

	<span class="token comment">// 使用channel来同步goroutine之间的执行状态</span>
	done <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token comment">// 运行一个 worker Go协程，并给予用于通知的通道。</span>
	<span class="token keyword">go</span> <span class="token function">worker</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span>
	<span class="token comment">// 程序将在接收到通道中 worker 发出的通知前一直阻塞。</span>
	<span class="token operator">&lt;-</span>done
	<span class="token comment">// 如果你把 &lt;- done 这行代码从程序中移除，程序甚至会在 worker还没开始运行时就结束了。</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">worker</span><span class="token punctuation">(</span>done <span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;working...&quot;</span><span class="token punctuation">)</span>
	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;done&quot;</span><span class="token punctuation">)</span>
	<span class="token comment">// 发送一个值来通知我们已经完工啦。</span>
	done <span class="token operator">&lt;-</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面代码中,如果 main 没有从 go worker 接收数据则 done 阻塞。这样就实现了 main 和 go worker 同步。
总之,channel 的阻塞特性可以用于不同 goroutine 之间的同步。当一个 goroutine Expects 另一个 goroutine 的操作结果或信号时,可以使用 channel 使其阻塞,等待另一个 goroutine 的操作。这是 channel 除了数据传输之外的另一个重要用途。</p> <h4 id="channel选择器"><a href="#channel选择器" class="header-anchor">#</a> channel选择器</h4> <p>在 Go 语言中,通道选择器可以用来监听多个通道上的操作并进行选择。它通过 select 关键字实现。</p> <p>select 的基本语法如下:</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">select</span> <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token operator">&lt;-</span>chan1<span class="token punctuation">:</span>
    <span class="token comment">// chan1 可读,执行该 case</span>
<span class="token keyword">case</span> chan2 <span class="token operator">&lt;-</span> <span class="token number">1</span><span class="token punctuation">:</span>
    <span class="token comment">// chan2 可写,执行该 case  </span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
    <span class="token comment">// 如果没有 case 可执行,执行 default</span>
<span class="token punctuation">}</span>
</code></pre></div><p>例如,这里是一个简单的例子:</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在我们的例子中，我们将从两个通道中选择。</span>
    c1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span>
    c2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span>

    <span class="token comment">// 开启第一个goroutine</span>
    <span class="token comment">// 休眠1s 然后异步向c1通道输入&quot;one&quot;</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
        c1 <span class="token operator">&lt;-</span> <span class="token string">&quot;one&quot;</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// 开启第二个goroutine</span>
    <span class="token comment">// 休眠2s 然后异步向c2通道输入&quot;two&quot;</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
        c2 <span class="token operator">&lt;-</span> <span class="token string">&quot;two&quot;</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// 使用通道选择器监听两个通道，谁先接收到值就输出谁</span>
    <span class="token comment">// 所以这个通道选择器一直接收到的是&quot;one&quot;</span>
    <span class="token keyword">select</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> msg1 <span class="token operator">:=</span> <span class="token operator">&lt;-</span>c1<span class="token punctuation">:</span>
        <span class="token function">println</span><span class="token punctuation">(</span>msg1<span class="token punctuation">)</span>
    <span class="token keyword">case</span> msg2 <span class="token operator">:=</span> <span class="token operator">&lt;-</span>c2<span class="token punctuation">:</span>
        <span class="token function">println</span><span class="token punctuation">(</span>msg2<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 输出</span>
    <span class="token comment">// one</span>
<span class="token punctuation">}</span>
</code></pre></div><h6 id="channel选择器的第一个用法-超时处理"><a href="#channel选择器的第一个用法-超时处理" class="header-anchor">#</a> channel选择器的第一个用法:超时处理</h6> <p>通过使用<b>time.After()</b>函数来定义一个指定时间之后的执行的通道。我们很容易的实现<b>超时处理</b>。</p> <p>下面是一个使用超时处理的例子:</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;strconv&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 定义双向通道c1和c2</span>
	c1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span>
	c2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span>

	<span class="token comment">// 开启goroutine 每个200ms向c1输入一个值 执行5次</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
			time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond <span class="token operator">*</span> <span class="token number">200</span><span class="token punctuation">)</span>
			c1 <span class="token operator">&lt;-</span> <span class="token string">&quot;result &quot;</span> <span class="token operator">+</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// 开启goroutine 每个300ms向c2输入一个值 执行5次</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
			time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond <span class="token operator">*</span> <span class="token number">300</span><span class="token punctuation">)</span>
			c2 <span class="token operator">&lt;-</span> <span class="token string">&quot;result &quot;</span> <span class="token operator">+</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// 定义一个独立的定时器</span>
	timeout <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">)</span>

	<span class="token comment">// for循环可以一直启用select监听c1和c2通道</span>
	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		<span class="token keyword">select</span> <span class="token punctuation">{</span>
		<span class="token keyword">case</span> res1 <span class="token operator">:=</span> <span class="token operator">&lt;-</span>c1<span class="token punctuation">:</span> <span class="token comment">// 输出c1通道接收到的值</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;received from chan c1: &quot;</span><span class="token punctuation">,</span> res1<span class="token punctuation">)</span>
		<span class="token keyword">case</span> res2 <span class="token operator">:=</span> <span class="token operator">&lt;-</span>c2<span class="token punctuation">:</span> <span class="token comment">// 输出c2通道接收到的值</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;received from chan c2: &quot;</span><span class="token punctuation">,</span> res2<span class="token punctuation">)</span>
		<span class="token keyword">case</span> <span class="token operator">&lt;-</span>timeout<span class="token punctuation">:</span> <span class="token comment">// 在1s后让通道选择器执行超时退出操作</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;timeout after 1s&quot;</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 输出</span>
	<span class="token comment">// received from chan c1:  result 1</span>
	<span class="token comment">// received from chan c2:  result 1</span>
	<span class="token comment">// received from chan c1:  result 2</span>
	<span class="token comment">// received from chan c1:  result 3</span>
	<span class="token comment">// received from chan c2:  result 2</span>
	<span class="token comment">// received from chan c1:  result 4</span>
	<span class="token comment">// received from chan c2:  result 3</span>
	<span class="token comment">// timeout after 1s</span>
<span class="token punctuation">}</span>
</code></pre></div><h6 id="channel选择器的第二个用法-非阻塞channel"><a href="#channel选择器的第二个用法-非阻塞channel" class="header-anchor">#</a> channel选择器的第二个用法:非阻塞channel</h6> <p>可以使用select的default语句来实现非阻塞通道的监听。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;strconv&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token comment">// 常规的通过通道发送和接收数据是阻塞的。然而，我们可以使用带一个 default 子句的 select 来实现非阻塞 的发送、接收，甚至是非阻塞的多路 select。</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 定义一个messages通道</span>
	messages <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span>

	<span class="token comment">// 使用goroutine异步，每个500ms向messages写入一条消息</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
			time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond <span class="token operator">*</span> <span class="token number">500</span><span class="token punctuation">)</span>
			messages <span class="token operator">&lt;-</span> <span class="token string">&quot;msg &quot;</span> <span class="token operator">+</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// 定义一个超时处理器</span>
	timeout <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span>

	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		<span class="token comment">// 如果在 messages 中存在，然后 select 将这个值带入 &lt;-messages case中。如果不是，就直接到 default 分支中。</span>
		<span class="token keyword">select</span> <span class="token punctuation">{</span>
		<span class="token keyword">case</span> msg <span class="token operator">:=</span> <span class="token operator">&lt;-</span>messages<span class="token punctuation">:</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>
		<span class="token keyword">case</span> <span class="token operator">&lt;-</span>timeout<span class="token punctuation">:</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;timeout 1&quot;</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span>
		<span class="token keyword">default</span><span class="token punctuation">:</span>
			time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond <span class="token operator">*</span> <span class="token number">300</span><span class="token punctuation">)</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;no message received&quot;</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 输出</span>
	<span class="token comment">// no message received</span>
	<span class="token comment">// no message received</span>
	<span class="token comment">// msg 1</span>
	<span class="token comment">// no message received</span>
	<span class="token comment">// no message received</span>
	<span class="token comment">// msg 2</span>
	<span class="token comment">// no message received</span>
	<span class="token comment">// no message received</span>
	<span class="token comment">// msg 3</span>
	<span class="token comment">// no message received</span>
	<span class="token comment">// no message received</span>
	<span class="token comment">// msg 4</span>
	<span class="token comment">// no message received</span>
	<span class="token comment">// no message received</span>
	<span class="token comment">// timeout 1</span>
<span class="token punctuation">}</span>
</code></pre></div><p>所以，select default的用来实现一个非阻塞的通道读写:</p> <ul><li>尝试向通道写入数据,如果通道已满,则选择 default</li> <li>尝试从通道读取数据,如果通道为空,则选择 default
这种“非阻塞”的特性可以用于在不确定通道状态的情况下尝试读写,如果不能成功则实现默认行为,而不是阻塞当前 goroutine。</li></ul> <h4 id="channel的关闭"><a href="#channel的关闭" class="header-anchor">#</a> channel的关闭</h4> <p>关闭 一个通道意味着不能再向这个通道发送值了。这个特性可以用来给这个通道的接收方传达工作已经完成的信息。通道需要关闭(close)的情况有两种:</p> <ul><li>当不再使用这个通道发送数据时,需要关闭通道</li> <li>对方可以通过通道的关闭状态来判断发送方是否结束工作</li></ul> <p>关闭通道的语法很简单,使用 close 关键字:</p> <div class="language-go extra-class"><pre class="language-go"><code>c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
<span class="token function">close</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
</code></pre></div><p>关闭通道主要有一下几个作用:</p> <ul><li>对已关闭的通道再发送数据会 panic,这可以确保不会向通道发送无效数据。</li> <li>对已关闭的通道进行接收(&lt;-chan)不会阻塞,而是立即返回通道元素类型的零值。这可以用于正常关闭接收方 goroutine。</li> <li>通过 select 中的 case &lt;-chan 语句,如果通道关闭,则会立即执行该 case,这可以用于检测通道是否关闭。</li> <li>可以通过通道接收时的第二个参数测试通道是否关闭,如果关闭则返回 true 。</li></ul> <p>例子:</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 定义一个工作数据接收通道</span>
	jobs <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
	<span class="token comment">// 定义一个多goroutine之间状态同步的通道</span>
	done <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

	<span class="token comment">// 开启goroutine异步监听jobs通道</span>
	<span class="token comment">// 如果有数据输出数据</span>
	<span class="token comment">// 如果通道关闭向状态同步通道同步关闭状态，然后退出当前goroutine</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token punctuation">{</span>
			j<span class="token punctuation">,</span> more <span class="token operator">:=</span> <span class="token operator">&lt;-</span>jobs
			<span class="token keyword">if</span> more <span class="token punctuation">{</span>
				fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;received job&quot;</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
				fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;received all jobs&quot;</span><span class="token punctuation">)</span>
				done <span class="token operator">&lt;-</span> <span class="token boolean">true</span>
				<span class="token keyword">return</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// 主goroutine向jobs写入数据</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		jobs <span class="token operator">&lt;-</span> i
	<span class="token punctuation">}</span>
	<span class="token comment">// 关闭通道</span>
	<span class="token function">close</span><span class="token punctuation">(</span>jobs<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;sent all jobs&quot;</span><span class="token punctuation">)</span>

	<span class="token comment">// 阻塞主goroutine 等待同步的状态 然后退出</span>
	<span class="token operator">&lt;-</span>done
<span class="token punctuation">}</span>
</code></pre></div><h4 id="channel的遍历"><a href="#channel的遍历" class="header-anchor">#</a> channel的遍历</h4> <p>Go 语言的通道(channel)可以使用 range 关键字进行遍历。遍历通道会一直阻塞到通道关闭。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// for range 来遍历通道</span>
	c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		c <span class="token operator">&lt;-</span> <span class="token number">1</span>
		c <span class="token operator">&lt;-</span> <span class="token number">2</span>
        <span class="token function">close</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">for</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> c <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 输出</span>
	<span class="token comment">// 1</span>
	<span class="token comment">// 2</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面的通道，如果在非关闭状态下遍历，会产生死锁。后面我们将学习goroutine的死锁。</p> <h2 id="扩展"><a href="#扩展" class="header-anchor">#</a> 扩展</h2> <h4 id="什么是goroutine的阻塞"><a href="#什么是goroutine的阻塞" class="header-anchor">#</a> 什么是goroutine的阻塞？</h4> <p>Goroutine 阻塞意味着 goroutine 被暂停执行,等待某个条件满足才继续执行。
Goroutine 可以因以下几个原因被阻塞:</p> <ul><li>通道阻塞:当从一个空通道接收数据时,goroutine 会被阻塞直到有数据发送到该通道。</li> <li>互斥锁阻塞:当 goroutine 尝试锁定一个已经被其他 goroutine 锁定的互斥锁时,它会被阻塞直到互斥锁被解锁。</li> <li>等待其他 goroutine:可以使用 WaitGroup 显式等待其他 goroutine 结束。goroutine 会被阻塞直到 WaitGroup 的计数减为 0。</li> <li>系统调用阻塞:当 goroutine 执行系统调用发生 IO 或涉及同步的操作时,它会被阻塞。例如文件读取,数据库查询等。</li> <li>定时器阻塞:goroutine 可以使用 time.Sleep 或 channel 和 select 实现定时器,在定时时间未到达前被阻塞。
阻塞的 goroutine 会被放入调度队列中,等待它所需要的资源或条件准备就绪后继续执行。</li></ul> <h4 id="什么是goroutine的死锁"><a href="#什么是goroutine的死锁" class="header-anchor">#</a> 什么是goroutine的死锁？</h4> <p>Goroutine 死锁指的是两个或多个 goroutine 因互相等待对方释放资源而陷入无限等待的状态。
死锁的四个必要条件:</p> <ul><li>互斥:一个资源每次只能被一个 goroutine 占有。</li> <li>占有且等待:goroutine 已经占有某资源,但还在等待其他被其他 goroutine 占有的资源。</li> <li>不可剥夺:资源在被占有期间不能被 goroutine 外力剥夺。</li> <li>循环等待:goroutine 形成了一个等待循环队列。</li></ul> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// for range 来遍历通道</span>
	c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		c <span class="token operator">&lt;-</span> <span class="token number">1</span>
		c <span class="token operator">&lt;-</span> <span class="token number">2</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">for</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> c <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 输出</span>
	<span class="token comment">// 1</span>
	<span class="token comment">// 2</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上，新开启的goroutine向通道c写入1,2两个值之后直接退出。但是main goroutine的for...range...还在等待通道c关闭或者继续往通道c里面写入数据。所以导致了死锁的情况。</p> <h4 id="阻塞与死锁的区别"><a href="#阻塞与死锁的区别" class="header-anchor">#</a> 阻塞与死锁的区别:</h4> <ul><li>阻塞的 goroutine 会在条件满足时被唤醒继续执行,死锁的 goroutine 却无法继续执行。</li> <li>阻塞通常是临时的,死锁发生后程序无法继续运行。</li> <li>阻塞不会导致资源占用不释放,死锁会导致有限资源被永久占用无法释放。
总之,理解 goroutine 的阻塞机制和死锁的区别可以避免 Go 程序出现死锁问题,编写出健壮的并发程序。阻塞是控制 goroutine 执行顺序的一种重要手段。</li></ul> <h2 id="解答"><a href="#解答" class="header-anchor">#</a> 解答</h2> <h4 id="实现步骤"><a href="#实现步骤" class="header-anchor">#</a> 实现步骤</h4> <ol><li>读取 CSV 文件,获取所有品类名称,存入 brands 数组。</li> <li>创建结果文件 result.csv 和 waitGroup。</li> <li>启动 goroutine,对 brands 数组中的每个品类名称调用接口打分,得到分数 score,并通过 channel 返回。</li> <li>从 channel 中获取分数 score,并写入结果文件 result.csv。</li> <li>使用 waitGroup 等待所有 goroutine 结束。</li></ol> <h4 id="实现代码"><a href="#实现代码" class="header-anchor">#</a> 实现代码</h4> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">&quot;encoding/csv&quot;</span>
    <span class="token string">&quot;os&quot;</span>
    <span class="token string">&quot;sync&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 读取 CSV 文件,获取所有品类名称</span>
    brands <span class="token operator">:=</span> <span class="token function">readBrandsFromCSV</span><span class="token punctuation">(</span><span class="token string">&quot;brands.csv&quot;</span><span class="token punctuation">)</span>

    <span class="token comment">// 创建结果文件和waitGroup</span>
    f<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token string">&quot;result.csv&quot;</span><span class="token punctuation">)</span>
    w <span class="token operator">:=</span> csv<span class="token punctuation">.</span><span class="token function">NewWriter</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>
    wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>brands<span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment">// 启动 goroutine 打分,并通过 channel 返回</span>
    scores <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> brand <span class="token operator">:=</span> <span class="token keyword">range</span> brands <span class="token punctuation">{</span>
        <span class="token keyword">go</span> <span class="token function">getScore</span><span class="token punctuation">(</span>brand<span class="token punctuation">,</span> scores<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 从channel获取分数并写入文件</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>brands<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        score <span class="token operator">:=</span> <span class="token operator">&lt;-</span>scores
        w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span>brands<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> score<span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 等待goroutine结束</span>
    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  

    <span class="token comment">// 关闭文件</span>
    w<span class="token punctuation">.</span><span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 读取 CSV 文件获取品类  </span>
<span class="token keyword">func</span> <span class="token function">readBrandsFromCSV</span><span class="token punctuation">(</span>path <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用接口打分,并通过channel返回    </span>
<span class="token keyword">func</span> <span class="token function">getScore</span><span class="token punctuation">(</span>brand <span class="token builtin">string</span><span class="token punctuation">,</span> scores <span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用接口,获取分数 score </span>
    score <span class="token operator">:=</span> <span class="token function">getScoreFromAPI</span><span class="token punctuation">(</span>brand<span class="token punctuation">)</span>  

    scores <span class="token operator">&lt;-</span> score  <span class="token comment">// 返回分数</span>
    wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment">// 通知waitGroup</span>
<span class="token punctuation">}</span>
</code></pre></div></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#问题" title="问题">问题</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#思考" title="思考">思考</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#学习" title="学习">学习</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#扩展" title="扩展">扩展</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#解答" title="解答">解答</a></div></div></div></div> <footer class="footer" data-v-3d9deeb8><div class="footer-left-wrap" data-v-3d9deeb8><ul class="contact" data-v-3d9deeb8><li class="contact-item" data-v-3d9deeb8><a href="https://github.com/fbbyqsyea" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-3d9deeb8><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-3d9deeb8><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-3d9deeb8></path></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-3d9deeb8><ul class="copyright" data-v-3d9deeb8><li class="copyright-item" data-v-3d9deeb8>MIT Licensed | Copyright © 2024-fbbyqsyea</li></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.20f2d714.js" defer></script><script src="/assets/js/6.86d33cf6.js" defer></script><script src="/assets/js/3.122d5fd9.js" defer></script><script src="/assets/js/36.b0bfa1bd.js" defer></script>
  </body>
</html>
