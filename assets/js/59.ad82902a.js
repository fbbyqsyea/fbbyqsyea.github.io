(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{360:function(t,a,e){"use strict";e.r(a);var s=e(5),i=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"redis-bitmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-bitmap"}},[t._v("#")]),t._v(" Redis Bitmap")]),t._v(" "),a("h2",{attrs:{id:"什么是bitmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是bitmap"}},[t._v("#")]),t._v(" 什么是Bitmap")]),t._v(" "),a("p",[t._v("位图(Bitmap)是一种在计算机领域广泛使用的数据结构,主要用于高效地表示和操作大量布尔值(0或1)的集合。它通过利用位级运算的特性,将每个布尔值存储在一个二进制位(bit)中,从而实现了空间高效和运算高效的目标。")]),t._v(" "),a("p",[t._v("位图的基本原理是使用一个连续的位序列(一个位就是0或1)来表示一组元素的集合。每个元素在位图中对应一个固定的位位置,如果该位为1,则表示该元素存在于集合中;反之,如果该位为0,则表示该元素不在集合中。")]),t._v(" "),a("p",[t._v("位图的实现通常使用一个位数组(bit array)或位向量(bit vector)来存储位序列。在实际应用中,由于大多数计算机系统以字节(8位)为基本存储单位,因此位图通常以字节数组的形式进行存储和操作。")]),t._v(" "),a("p",[t._v("位图的主要优点在于:")]),t._v(" "),a("p",[t._v("空间高效:对于大规模的布尔值集合,位图比使用其他数据结构(如哈希表或树)更加节省内存空间。\n操作高效:由于位运算在底层由CPU直接支持,因此对位图执行逻辑运算(如并集、交集、差集等)的效率非常高。\n随机访问:位图支持常数时间的随机访问,可以快速查找某个元素是否存在于集合中。\n位图的应用场景非常广泛,例如:")]),t._v(" "),a("ul",[a("li",[t._v("布隆过滤器(Bloom Filter):用于快速判断一个元素是否属于集合。")]),t._v(" "),a("li",[t._v("数据压缩:可以高效地压缩大量重复的布尔值数据。")]),t._v(" "),a("li",[t._v("数据库索引:用于标记数据库表中某些行或列的存在情况。")]),t._v(" "),a("li",[t._v("网络包过滤:用于跟踪网络流量中出现过的IP地址或端口号。")]),t._v(" "),a("li",[t._v("任务调度:用于标记系统中任务的运行状态。")])]),t._v(" "),a("p",[t._v("尽管位图具有诸多优点,但它也有一些局限性。例如,它不适合存储需要关联其他信息的数据,因为位图只能存储布尔值。此外,如果需要存储的元素范围很大,位图可能会占用大量内存空间。")]),t._v(" "),a("p",[t._v("总的来说,位图是一种简单但高效的数据结构,在需要处理大量布尔值数据的场景中具有广泛的应用价值。")]),t._v(" "),a("h2",{attrs:{id:"redis中的bitmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis中的bitmap"}},[t._v("#")]),t._v(" Redis中的Bitmap")]),t._v(" "),a("p",[t._v("Redis提供了Bitmap这种数据结构,并针对Bitmap实现了一组高效的命令,使得我们能够方便地使用Bitmap在Redis中表示和操作二进制数据。")]),t._v(" "),a("p",[t._v("在Redis中,Bitmap是使用字符串键(key)来存储位数组。每个二进制位的值要么是0要么是1,可以用于存储多种类型的信息,比如一个用户是否访问过某个页面,某个IP是否被阻止等。Redis提供了多个命令来对Bitmap进行操作,主要包括:")]),t._v(" "),a("h4",{attrs:{id:"setbit"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setbit"}},[t._v("#")]),t._v(" SETBIT")]),t._v(" "),a("ul",[a("li",[t._v("Available since: 2.2.0")]),t._v(" "),a("li",[t._v("Time complexity: O(1)")])]),t._v(" "),a("p",[t._v("设置或清除存储在键的值字符串中偏移量为offset的二进制位")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("SETBIT key offset value \n")])])]),a("h4",{attrs:{id:"getbit"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#getbit"}},[t._v("#")]),t._v(" GETBIT")]),t._v(" "),a("ul",[a("li",[t._v("Available since: 2.2.0")]),t._v(" "),a("li",[t._v("Time complexity: O(1)")])]),t._v(" "),a("p",[t._v("返回储存在键的字符串值中偏移offset处的二进制位的值")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("GETBIT key offset \n")])])]),a("h4",{attrs:{id:"bitcount"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bitcount"}},[t._v("#")]),t._v(" BITCOUNT")]),t._v(" "),a("ul",[a("li",[t._v("Available since: 2.6.0")]),t._v(" "),a("li",[t._v("Time complexity: O(N)")])]),t._v(" "),a("p",[t._v("计算字符串从start字节到end字节之间值为1的位的数量")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("BITCOUNT key [start end [BYTE | BIT]]\n")])])]),a("h4",{attrs:{id:"bitop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bitop"}},[t._v("#")]),t._v(" BITOP")]),t._v(" "),a("ul",[a("li",[t._v("Available since: 2.6.0")]),t._v(" "),a("li",[t._v("Time complexity: O(N)")])]),t._v(" "),a("p",[t._v("对一个或多个二进制位串执行任意位操作(AND、OR、NOT、XOR),并将结果保存到destkey中")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("BITOP <AND | OR | XOR | NOT> destkey key [key ...]\n")])])]),a("h4",{attrs:{id:"bitpos"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bitpos"}},[t._v("#")]),t._v(" BITPOS")]),t._v(" "),a("ul",[a("li",[t._v("Available since: 2.8.7")]),t._v(" "),a("li",[t._v("Time complexity: O(N)")])]),t._v(" "),a("p",[t._v("返回位串中第一个值为bit的二进制位的位置")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("BITPOS key bit [start [end [BYTE | BIT]]]\n")])])])])}),[],!1,null,null,null);a.default=i.exports}}]);